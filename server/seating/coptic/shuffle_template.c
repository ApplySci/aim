#include <stdio.h>
#include <stdint.h>
#include <string.h>

#define HANCHAN #HANCHAN#
#define TABLES #TABLES#
#define PLAYERS TABLES*4
#define TOLERABLE_REPEATS #TOLERABLE_REPEATS#
/*
reads in the file generated by coptic
*/

uint8_t tables[PLAYERS][TABLES];
uint8_t seats[HANCHAN][TABLES][4];

void swap_rows(uint8_t row[TABLES][4], uint8_t b, uint8_t c) {
    uint8_t temp[4];
    for (uint8_t s = 0; s < 4; s++) {
      tables[row[b][s]][b]--;
      tables[row[c][s]][b]++;
      tables[row[b][s]][c]++;
      tables[row[c][s]][c]--;
    }
    memcpy(temp, row[b], 4);
    memcpy(row[b], row[c], 4);
    memcpy(row[c], temp, 4);
}

void count_tables() {
  uint8_t p;
  for (uint8_t h = 0; h < HANCHAN; h++) {
    for (uint8_t t = 0; t < TABLES; t++) {
      for (uint8_t s = 0; s < 4; s++) {
        p = seats[h][t][s];
        tables[p][t]++;
      }
    }
  }
}

int score_seats() {
  /*
   check no player is on any one table too often
  */
  int score = 0;
  for (uint8_t p = 0; p < PLAYERS; p++) {
    uint8_t tolerated = 0;
    for (uint8_t t = 0; t < TABLES; t++) {
      if (tables[p][t] > TOLERABLE_REPEATS) {
        score += (tables[p][t] - TOLERABLE_REPEATS) * (tables[p][t] - TOLERABLE_REPEATS) * 1000;
      } else if (tables[p][t] == TOLERABLE_REPEATS) {
        tolerated++;
      }
    }
    // score += tolerated * tolerated;
  }
  return score;
}

int main(int argc, char *argv[]) {
  char *filename;
  if(argc > 1) {
      filename = argv[1];
  } else {
      filename = "coptic.coptic/default.txt";
  }

  FILE *file = fopen(filename, "r");
  if (file == NULL) {
      printf("Could not open file\n");
      return 1;
  }

  uint8_t seats[HANCHAN][TABLES][4];
  char line[256];
  while (fgets(line, sizeof(line), file)) {
      if (strstr(line, "SEATING BY ROUND, BY TABLE") != NULL) {
          for (int i = 0; i < HANCHAN; i++) {
              for (int j = 0; j < TABLES; j++) {
                  fscanf(file, "%hhu,%hhu,%hhu,%hhu, ;", &seats[i][j][0], &seats[i][j][1], &seats[i][j][2], &seats[i][j][3]);
              }
          }
          break;
      }
  }
 
  fclose(file);

  for (uint8_t h = 0; h < HANCHAN; h++) {
    for (uint8_t t = 0; t < TABLES; t++) {
      for (uint8_t s = 0; s < 4; s++) {
        uint8_t p = seats[h][t][s];
        tables[p][t]++;
      }
    }
  }

  printf("\n\n initial tables\n\n");
  // Print the results
  for (int i = 0; i < PLAYERS; i++) {
      for (int j = 0; j < TABLES; j++) {
          printf("%u, ", tables[i][j]);
      }
      printf("\n");
  }

  int score = score_seats();
  int score2;
  int last_score = score + 1;
  printf("initial score: %d", score);

  while (score < last_score) {
    last_score = score;
    printf("\n");
    for (int h  = 0; h < HANCHAN; h++) {
      // shuffle tables within each hanchan to reduce players visiting the same table twice
      for (int t = 0; t < TABLES; t++) {
        for (int t2 = t + 1; t2 < TABLES; t2++) {
          swap_rows(seats[h], t, t2);
          score2 = score_seats();
          if (score2 < score) {
            printf("%d, ", score2);
            score = score2;
            if (score == 0) {
              printf("\n fully optimal solution found\n");
              goto optimised;
            }
          } else {
            // no improvement, so swap back
            swap_rows(seats[h], t, t2); 
          }
        }
      }
    }
  }

  optimised:
  
  printf("\n\nSEATING BY ROUND, BY TABLE\n\nseats = [\n");
  for (int h = 0; h < HANCHAN; h++) {
      printf("    [\n");
      for (int t = 0; t < TABLES; t++) {
        printf("    [");  
          for (int s = 0; s < 4; s++) {
            printf("%3u, ", seats[h][t][s] + 1);
          }
          printf("],\n");
      }
      printf("    ],\n");
  }
  printf("]\n\n\n");

  printf("\n\nTABLE COUNT BY PLAYER\n\n");
  // Print the results
  for (int i = 0; i < 32; i++) {
      for (int j = 0; j < TABLES; j++) {
          printf("%u, ", tables[i][j]);
      }
      printf("\n");
  }
  printf("\n\nFINAL SCORE: %5d\n\n", score);
  return 0;
} 
