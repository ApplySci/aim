{% extends "runbase.html" %}

{% block title %}Manage Player Substitutions - {{ current_user.live_tournament.title }}{% endblock %}

{% block content %}
<h2>Manage player substitutions / change the number of tables</h2>

<p>{{ completed_rounds}} hanchan completed. Substitutions will be made for all hanchan from {{ completed_rounds + 1 }} onwards</p>
<p><strong>Total dropouts so far:</strong> {{ total_dropouts }} player(s)</p>

<div id="playerManagement">
    <div id="currentPlayersSection">
        <h3>Current Players</h3>
        <select id="currentPlayerSelect" multiple size="16"></select>
        <button id="moveToDropped" class="move-button">→</button>
    </div>
    <div id="droppedPlayersSection">
        <h3>Dropped Out Players</h3>
        <button id="moveToActive" class="move-button">←</button>
        <select id="droppedPlayerSelect" multiple></select>
    </div>
</div>

<div id="tableReductionOption">
    <h4>Table Count Reduction</h4>
    <p>The number of active tables has reduced. Would you like to:</p>
    <div>
        <input type="checkbox" id="reduceTableCount" name="reduceTableCount">
        <label for="reduceTableCount">Permanently reduce the number of tables to match the current player count</label>
    </div>
    <p class="note">
        <strong>Note:</strong> If unchecked, the original table count will be maintained, allowing for players to rejoin later.
    </p>
</div>

<div id="automaticTableReduction" class="hidden">
    <h4>Automatic Table Reduction Required</h4>
    <p id="autoReductionMessage">Not enough substitutes available to fill tables. Some active substitutes must be deactivated.</p>
    
    <div id="substituteDeactivationSection">
        <h5>Substitutes to Deactivate:</h5>
        <div id="substituteDeactivationList">
            <!-- Will be populated by JavaScript -->
        </div>
        <p class="note">
            <strong>Auto-selected by seating ID (highest first).</strong> You can change the selection - the system will automatically maintain the correct number of selections.
        </p>
    </div>
    
    <div>
        <input type="checkbox" id="autoReduceTableCount" name="autoReduceTableCount" checked disabled>
        <label for="autoReduceTableCount">Automatically reduce table count (required)</label>
    </div>
</div>

<div id="optimizationSettings" class="hidden">
    <div>
        <p>We need to adjust the seating to accommodate the reduced number of tables.</p>
        <p>⚡ This will run in your browser. More calculation time might generate better results, but will consume a little more power,
            which might be relevant if you're running a laptop on low battery.</p>
        <label for="timeLimit">Calculation time: </label>
        <select id="timeLimit">
            <option value="15">15 seconds</option>
            <option value="30" selected>30 seconds</option>
            <option value="60">1 minute</option>
            <option value="120">2 minutes</option>
            <option value="300">5 minutes</option>
        </select>
    </div>
</div>

<p>
    <button id="calculateSubstitutions">Calculate Substitutions</button>
    <button id="undoSubstitution" class="hidden">Undo Last Substitution</button>
</p>
<div id="substitutionPreview" class="hidden">
    <div id="optimizationContainer">
        <pre id="optimizationProgress" class="monospace-output"></pre>
        <div id="statisticsContainer" class="hidden">
            <h4>Statistics Comparison</h4>
            <div id="statsGrid">
                <div class="stats-column">
                    <h5>Current Seating</h5>
                    <pre id="currentStats" class="monospace-output"></pre>
                </div>
                <div class="stats-column">
                    <h5>New Seating</h5>
                    <pre id="newStats" class="monospace-output"></pre>
                </div>
            </div>
        </div>
        <h3>Substitution Preview</h3>
        <pre id="previewContent" class="monospace-output"></pre>
    </div>
    <button id="confirmSubstitutions">Do these substitutions</button>
    <button id="cancelSubstitutions">Cancel</button>
</div>
<p><a href="{{ url_for('run.run_tournament') }}">Back to main Run Tournament page</a></p>

<style>
#playerManagement {
    display: flex;
    justify-content: flex-start;
    gap: 100px;
}

#currentPlayersSection, 
#droppedPlayersSection {
    position: relative;
    width: 300px;
}

.hidden {
    display: none;
}

#currentPlayerSelect,
#droppedPlayerSelect {
    width: 100%;
}

.move-button {
    position: absolute;
    top: 55px;
    background-color: blue;
    color: white;
    font-size: 1.2em;
}

#moveToActive {
    left: -40px;
}

#moveToDropped {
    right: -40px;
}

#tableReductionOption {
    margin: 20px 0;
    padding: 15px;
    border-radius: 4px;
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
}

#tableReductionOption div {
    margin-top: 10px;
}

.note {
    font-style: italic;
    margin-top: 10px;
    color: #6c757d;
}

#optimizationContainer {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.monospace-output {
    font-family: monospace;
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    border: 1px solid #ddd;
    white-space: pre-wrap;
    max-height: 400px;
    overflow-y: auto;
}

#optimizationProgress {
    border-left: 3px solid #4CAF50;
}

#previewContent {
    border-left: 3px solid #2196F3;
}

#statsGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 10px 0;
}

.stats-column {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
}

.stats-column h5 {
    margin-top: 0;
    color: #495057;
    border-bottom: 2px solid #dee2e6;
    padding-bottom: 5px;
}

#optimizationSettings > div {
    background-color: #f8f9fa;
    border-left: 4px solid #17a2b8;
    padding: 15px;
    margin: 10px 0;
    border-radius: 4px;
}

#optimizationSettings p {
    margin: 0 0 10px 0;
    color: #495057;
}

#timeLimit {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ced4da;
}

#automaticTableReduction {
    margin: 20px 0;
    padding: 15px;
    border-radius: 4px;
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
}

#automaticTableReduction h4 {
    color: #856404;
    margin-top: 0;
}

#substituteDeactivationSection {
    margin: 15px 0;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #dee2e6;
}

#substituteDeactivationList {
    margin: 10px 0;
}

.substitute-deactivation-item {
    display: flex;
    align-items: center;
    margin: 5px 0;
    padding: 8px;
    background-color: white;
    border-radius: 4px;
    border: 1px solid #dee2e6;
}

.substitute-deactivation-item input[type="checkbox"] {
    transform: scale(1.2);
    margin-right: 15px;
}

.substitute-deactivation-item.recommended {
    background-color: #e7f3ff;
    border-color: #b3d9ff;
}

.substitute-deactivation-item label {
    cursor: pointer;
    user-select: none;
    font-weight: 500;
}

.substitute-deactivation-item:hover {
    background-color: #f8f9fa;
    border-color: #6c757d;
}

.substitute-deactivation-item.recommended:hover {
    background-color: #d1ecf1;
    border-color: #85c1e9;
}
</style>

{% endblock %}

{% block scripts %}
{{ super() }}
<script src="{{ url_for('static', filename='js/seating/stats.js') }}"></script>
<script src="{{ url_for('static', filename='js/seating/optimizer.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    //
    // DOM Element References
    //
    const currentPlayerSelect = document.getElementById('currentPlayerSelect');
    const droppedPlayerSelect = document.getElementById('droppedPlayerSelect');
    const moveToDroppedButton = document.getElementById('moveToDropped');
    const moveToActiveButton = document.getElementById('moveToActive');
    const calculateButton = document.getElementById('calculateSubstitutions');
    const confirmButton = document.getElementById('confirmSubstitutions');
    const cancelButton = document.getElementById('cancelSubstitutions');
    const undoButton = document.getElementById('undoSubstitution');
    const substitutionPreview = document.getElementById('substitutionPreview');
    const previewContent = document.getElementById('previewContent');
    const optimizationSettings = document.getElementById('optimizationSettings');
    const timeLimit = document.getElementById('timeLimit');
    const reduceTableCountCheckbox = document.getElementById('reduceTableCount');

    //
    // Data Initialization
    //
    let allPlayers = {{ players|tojson }};
    let currentPlayers = allPlayers.filter(p => p.status === 'active');
    let droppedPlayers = allPlayers.filter(p => p.status === 'dropped');
    let substitutes = allPlayers.filter(p => p.status === 'substitute');
    let seating = {{ seating|tojson }};
    let automaticTableReductionState = { required: false, substitutesToDeactivate: [] };
    
    // Initial render
    renderPlayers();

    //
    // Player List Management Functions
    //
    function renderPlayers() {
        currentPlayers.sort((a, b) => a.name.localeCompare(b.name));
        droppedPlayers.sort((a, b) => a.name.localeCompare(b.name));

        currentPlayerSelect.innerHTML = '';
        currentPlayers.forEach(player => {
            const option = new Option(`${player.name} (ID: ${player.registration_id})`, player.registration_id);
            currentPlayerSelect.add(option);
        });

        droppedPlayerSelect.innerHTML = '';
        droppedPlayers.forEach(player => {
            const option = new Option(`${player.name} (ID: ${player.registration_id})`, player.registration_id);
            droppedPlayerSelect.add(option);
        });

        const maxSize = parseInt(currentPlayerSelect.getAttribute('size'));
        droppedPlayerSelect.size = Math.min(Math.max(droppedPlayers.length, 1), maxSize);

        updateOptimizationSettings();
    }

    function getDroppedOutPlayers() {
        const result = droppedPlayers.map(player => parseInt(player.seating_id)).filter(id => !isNaN(id));
        console.log('getDroppedOutPlayers called:');
        console.log('  droppedPlayers:', droppedPlayers);
        console.log('  seating_ids:', droppedPlayers.map(p => p.seating_id));
        console.log('  result:', result);
        return result;
    }

    //
    // Automatic Table Reduction Logic
    //
    function checkAutomaticTableReduction() {
        const activeSubstitutes = currentPlayers.filter(p => p.substituted_for && p.substituted_for !== "");
        const availableSubstitutes = substitutes.length;
        const currentActiveCount = currentPlayers.length;
        
        // Calculate players needed to fill to next multiple of 4
        const playersNeededForNextTable = (4 - (currentActiveCount % 4)) % 4;
        
        // Check if we need automatic table reduction
        const mustReduceTables = playersNeededForNextTable > availableSubstitutes && activeSubstitutes.length > 0;
        
        if (mustReduceTables) {
            // Calculate target player count (largest multiple of 4 <= current count)
            const targetPlayerCount = Math.floor(currentActiveCount / 4) * 4;
            const substitutesToDeactivateCount = currentActiveCount - targetPlayerCount;
            
            // Sort active substitutes by seating ID (descending) for priority deactivation
            const sortedActiveSubstitutes = activeSubstitutes
                .filter(p => p.seating_id) // Ensure seating_id exists
                .sort((a, b) => parseInt(b.seating_id) - parseInt(a.seating_id));
            
            const substitutesToDeactivate = sortedActiveSubstitutes.slice(0, Math.min(substitutesToDeactivateCount, sortedActiveSubstitutes.length));
            
            console.log('Automatic table reduction required:');
            console.log('  Current active count:', currentActiveCount);
            console.log('  Target player count:', targetPlayerCount);
            console.log('  Available substitutes:', availableSubstitutes);
            console.log('  Active substitutes:', activeSubstitutes.length);
            console.log('  Substitutes to deactivate:', substitutesToDeactivate);
            
            return {
                required: true,
                currentActiveCount: currentActiveCount,
                targetPlayerCount: targetPlayerCount,
                substitutesToDeactivate: substitutesToDeactivate,
                availableSubstitutes: availableSubstitutes,
                playersNeededForNextTable: playersNeededForNextTable
            };
        }
        
        return { required: false };
    }

    function renderAutomaticTableReductionUI(reductionState) {
        const automaticTableReduction = document.getElementById('automaticTableReduction');
        const autoReductionMessage = document.getElementById('autoReductionMessage');
        const substituteDeactivationList = document.getElementById('substituteDeactivationList');
        
        if (!reductionState.required) {
            automaticTableReduction.style.display = 'none';
            return;
        }
        
        // Show the automatic table reduction section
        automaticTableReduction.style.display = 'block';
        
        // Calculate required deactivations
        const requiredDeactivations = reductionState.currentActiveCount - reductionState.targetPlayerCount;
        
        // Update message
        const tablesFrom = Math.ceil(reductionState.currentActiveCount / 4);
        const tablesTo = Math.ceil(reductionState.targetPlayerCount / 4);
        autoReductionMessage.textContent = `Not enough substitutes available (${reductionState.availableSubstitutes} available, ${reductionState.playersNeededForNextTable} needed). ` +
            `Tables will reduce from ${tablesFrom} to ${tablesTo}. Exactly ${requiredDeactivations} active substitute${requiredDeactivations !== 1 ? 's' : ''} must be deactivated.`;
        
        // Clear existing list
        substituteDeactivationList.innerHTML = '';
        
        // Create a helper function to find player name by registration ID
        function getPlayerNameByRegistrationId(regId) {
            const player = allPlayers.find(p => p.registration_id === regId);
            return player ? player.name : regId;
        }
        
        // Get and sort active substitutes by seating ID (descending)
        const activeSubstitutes = currentPlayers
            .filter(p => p.substituted_for && p.substituted_for !== "")
            .filter(p => p.seating_id)
            .sort((a, b) => parseInt(b.seating_id) - parseInt(a.seating_id));
        
        // Store required deactivations count for checkbox management
        substituteDeactivationList.dataset.requiredCount = requiredDeactivations;
        
        // Create checkboxes for each substitute that could be deactivated
        activeSubstitutes.forEach((substitute, index) => {
            const div = document.createElement('div');
            div.className = 'substitute-deactivation-item';
            
            const isRecommended = index < requiredDeactivations;
            if (isRecommended) {
                div.classList.add('recommended');
            }
            
            const substitutedForName = getPlayerNameByRegistrationId(substitute.substituted_for);
            
            div.innerHTML = `
                <input type="checkbox" id="deactivate_${substitute.registration_id}" 
                       ${isRecommended ? 'checked' : ''} 
                       data-registration-id="${substitute.registration_id}"
                       data-seating-id="${substitute.seating_id}"
                       data-priority="${index}">
                <label for="deactivate_${substitute.registration_id}">
                    ${substitute.name} (Seating ID: ${substitute.seating_id}, substituting for: ${substitutedForName})
                </label>
            `;
            
            substituteDeactivationList.appendChild(div);
        });
        
        // Add smart checkbox behavior
        setupSmartCheckboxBehavior();
    }

    function setupSmartCheckboxBehavior() {
        const substituteDeactivationList = document.getElementById('substituteDeactivationList');
        const requiredCount = parseInt(substituteDeactivationList.dataset.requiredCount);
        const checkboxes = substituteDeactivationList.querySelectorAll('input[type="checkbox"]');
        
        // Add event listeners to all checkboxes
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function(event) {
                handleSmartCheckboxChange(requiredCount, event.target);
            });
        });
    }

    function handleSmartCheckboxChange(requiredCount, clickedCheckbox) {
        const checkboxes = document.querySelectorAll('#substituteDeactivationList input[type="checkbox"]');
        const checkedBoxes = document.querySelectorAll('#substituteDeactivationList input[type="checkbox"]:checked');
        const checkedCount = checkedBoxes.length;
        
        console.log(`Smart checkbox change: clicked=${clickedCheckbox.dataset.registrationId}, checked=${clickedCheckbox.checked}, total checked=${checkedCount}, required=${requiredCount}`);
        
        let adjustmentsMade = false;
        let adjustedCheckboxes = [];
        
        if (checkedCount < requiredCount) {
            // User unchecked a box - need to check more boxes
            // Find the highest priority unchecked box (excluding the one the user just unchecked)
            const uncheckedBoxes = Array.from(checkboxes)
                .filter(cb => !cb.checked && cb !== clickedCheckbox)
                .sort((a, b) => parseInt(a.dataset.priority) - parseInt(b.dataset.priority));
            
            console.log('Need to auto-check boxes:', uncheckedBoxes.map(cb => cb.dataset.registrationId));
            
            const toCheck = requiredCount - checkedCount;
            for (let i = 0; i < toCheck && i < uncheckedBoxes.length; i++) {
                uncheckedBoxes[i].checked = true;
                adjustmentsMade = true;
                adjustedCheckboxes.push(uncheckedBoxes[i]);
                
                console.log(`Auto-checked: ${uncheckedBoxes[i].dataset.registrationId}`);
                
                // Add visual feedback with animation
                const item = uncheckedBoxes[i].closest('.substitute-deactivation-item');
                item.classList.add('recommended');
                item.style.transition = 'all 0.3s ease';
                item.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    item.style.transform = 'scale(1)';
                }, 300);
            }
        } else if (checkedCount > requiredCount) {
            // User checked a box - need to uncheck some boxes
            // Find the lowest priority checked boxes (excluding the one the user just checked)
            const checkedBoxesSorted = Array.from(checkedBoxes)
                .filter(cb => cb !== clickedCheckbox)
                .sort((a, b) => parseInt(b.dataset.priority) - parseInt(a.dataset.priority));
            
            console.log('Need to auto-uncheck boxes:', checkedBoxesSorted.map(cb => cb.dataset.registrationId));
            
            const toUncheck = checkedCount - requiredCount;
            for (let i = 0; i < toUncheck; i++) {
                checkedBoxesSorted[i].checked = false;
                adjustmentsMade = true;
                adjustedCheckboxes.push(checkedBoxesSorted[i]);
                
                console.log(`Auto-unchecked: ${checkedBoxesSorted[i].dataset.registrationId}`);
                
                // Add visual feedback for the unchecked item
                const item = checkedBoxesSorted[i].closest('.substitute-deactivation-item');
                item.classList.remove('recommended');
                item.style.transition = 'all 0.3s ease';
                item.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    item.style.transform = 'scale(1)';
                }, 300);
            }
        }
        
        // Update visual feedback for all checkboxes
        checkboxes.forEach(checkbox => {
            const item = checkbox.closest('.substitute-deactivation-item');
            if (checkbox.checked) {
                item.classList.add('recommended');
            } else {
                item.classList.remove('recommended');
            }
        });
        
        // Highlight the clicked checkbox to show user's choice was respected
        const clickedItem = clickedCheckbox.closest('.substitute-deactivation-item');
        clickedItem.style.transition = 'all 0.3s ease';
        clickedItem.style.boxShadow = '0 0 0 3px rgba(40, 167, 69, 0.3)';
        setTimeout(() => {
            clickedItem.style.boxShadow = '';
        }, 1000);
        
        // Show a brief tooltip if adjustments were made
        if (adjustmentsMade) {
            const action = clickedCheckbox.checked ? 'checked' : 'unchecked';
            const adjustedNames = adjustedCheckboxes.map(cb => 
                allPlayers.find(p => p.registration_id === cb.dataset.registrationId)?.name || cb.dataset.registrationId
            );
            showSmartSelectionFeedback(requiredCount, action, adjustedNames);
        }
    }

    function showSmartSelectionFeedback(requiredCount, action = 'adjusted', adjustedNames = []) {
        // Create or update feedback message
        let feedback = document.getElementById('smartSelectionFeedback');
        if (!feedback) {
            feedback = document.createElement('div');
            feedback.id = 'smartSelectionFeedback';
            feedback.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 10px 15px;
                border-radius: 4px;
                font-size: 14px;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s ease;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            `;
            document.body.appendChild(feedback);
        }
        
        // Create contextual message based on the action
        let message;
        const namesText = adjustedNames.length > 0 ? ` (${adjustedNames.join(', ')})` : '';
        
        if (action === 'checked') {
            message = `✓ Your selection respected - automatically unselected${namesText} to maintain exactly ${requiredCount}`;
        } else if (action === 'unchecked') {
            message = `✓ Your selection respected - automatically selected${namesText} to maintain exactly ${requiredCount}`;
        } else {
            message = `✓ Selection adjusted to maintain exactly ${requiredCount} substitute${requiredCount !== 1 ? 's' : ''}`;
        }
        
        feedback.textContent = message;
        feedback.style.opacity = '1';
        
        // Auto-hide after 3 seconds (longer for more informative messages)
        setTimeout(() => {
            feedback.style.opacity = '0';
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.parentNode.removeChild(feedback);
                }
            }, 300);
        }, 3000);
    }

    // New function to check if table reduction options should be displayed
    function updateTableReductionOptions() {
        const droppedCount = droppedPlayers.length;
        const totalDropouts = {{ total_dropouts }};
        const completedRounds = {{ completed_rounds }};
        const tableReductionOption = document.getElementById('tableReductionOption');
        const optimizationSettings = document.getElementById('optimizationSettings');
        const currentActiveCount = currentPlayers.length;
        
        // Check for automatic table reduction first
        automaticTableReductionState = checkAutomaticTableReduction();
        renderAutomaticTableReductionUI(automaticTableReductionState);
        
        if (automaticTableReductionState.required) {
            // Hide manual table reduction options when automatic is required
            tableReductionOption.style.display = 'none';
            optimizationSettings.style.display = 'block';
            return;
        }
        
        // Original manual table reduction logic
        const canReduceTables = Math.floor(currentActiveCount / 4) < Math.ceil((currentActiveCount + totalDropouts) / 4);
        
        if (completedRounds === 0 && canReduceTables && totalDropouts >= 4) {
            tableReductionOption.style.display = 'block';
            reduceTableCountCheckbox.checked = true;
            optimizationSettings.style.display = (currentActiveCount >= 4 * {{ min_tables }}) ? 'none' : 'block';
            
            // Update the description to show total dropouts
            const tableReductionText = document.querySelector('#tableReductionOption p');
            tableReductionText.textContent = `With ${totalDropouts} total dropouts, the number of active tables has reduced from ${Math.ceil((currentActiveCount + totalDropouts) / 4)} to ${Math.ceil(currentActiveCount / 4)}. Would you like to:`;
        } else {
            tableReductionOption.style.display = 'none';
            reduceTableCountCheckbox.checked = false;
            optimizationSettings.style.display = droppedCount >= 4 ? 'block' : 'none';
        }    
    }

    // Replace existing updateOptimizationSettings function
    function updateOptimizationSettings() {
        updateTableReductionOptions();
    }

    //
    // Statistics and Preview Functions
    //
    function formatStats(stats) {
        // Check if there are any non-zero indirect meetings
        const hasIndirectMeetings = stats.indirects && stats.indirects.some(v => v > 0);
        const indirectText = hasIndirectMeetings 
            ? stats.indirects.map((v, i) => `${i}x: ${v}`).filter(Boolean).join(', ')
            : 'N/A - all pairs meet directly';
            
        return [
            'Direct Meetings:     ' + stats.meets.map((v, i) => `${i}x: ${v}`).filter(Boolean).join(', '),
            'Indirect Meetings:   ' + indirectText,
            'Table Distribution:  ' + stats.tables.map((v, i) => `${i}x: ${v}`).filter(Boolean).join(', '),
            'Wind Distribution:   ' + stats.wind.map((v, i) => `${i}x: ${v}`).filter(Boolean).join(', '),
            'Repeat 3p Groups:    ' + stats.repeat3,
            'Repeat 4p Groups:    ' + stats.repeat4
        ].join('\n');
    }

    function generateSubstitutionPreview(oldSeating, newSeating) {
        const preview = [];
        for (let roundNum = 0; roundNum < oldSeating.length; roundNum++) {
            const roundChanges = [];
            for (let tableNum = 0; tableNum < oldSeating[roundNum].length; tableNum++) {
                const tableChanges = [];
                for (let seatNum = 0; seatNum < 4; seatNum++) {
                    const oldPlayer = oldSeating[roundNum][tableNum][seatNum];
                    const newPlayer = newSeating[roundNum][tableNum][seatNum];
                    if (oldPlayer !== newPlayer) {
                        tableChanges.push(`Seat ${seatNum + 1}: ${oldPlayer} -> ${newPlayer}`);
                    }
                }
                if (tableChanges.length > 0) {
                    if (newSeating[roundNum][tableNum].every(player => player === 0)) {
                        roundChanges.push(`Table ${tableNum + 1}: empty`);
                    } else {
                        roundChanges.push(`Table ${tableNum + 1}: ${tableChanges.join(', ')}`);
                    }
                }
            }
            if (roundChanges.length > 0) {
                preview.push(`Round ${roundNum + 1}: ${roundChanges.join('; ')}`);
            }
        }
        return preview;
    }

    //
    // Event Handlers
    //
    moveToDroppedButton.addEventListener('click', function() {
        console.log('=== MOVING PLAYERS TO DROPPED ===');
        Array.from(currentPlayerSelect.selectedOptions).forEach(option => {
            const player = currentPlayers.find(p => p.registration_id === option.value);
            if (player) {
                console.log('Moving player to dropped:', player);
                player.status = 'dropped';
                player.is_current = false;
                currentPlayers = currentPlayers.filter(p => p.registration_id !== player.registration_id);
                droppedPlayers.push(player);
            }
        });
        console.log('After move - currentPlayers:', currentPlayers.length);
        console.log('After move - droppedPlayers:', droppedPlayers.length);
        renderPlayers();
        // Check table reduction options after moving players
        updateTableReductionOptions();
    });

    moveToActiveButton.addEventListener('click', function() {
        Array.from(droppedPlayerSelect.selectedOptions).forEach(option => {
            const player = droppedPlayers.find(p => p.registration_id === option.value);
            if (player) {
                player.status = 'active';
                player.is_current = true;
                droppedPlayers = droppedPlayers.filter(p => p.registration_id !== player.registration_id);
                currentPlayers.push(player);
            }
        });
        renderPlayers();
        // Check table reduction options after moving players
        updateTableReductionOptions();
    });

    // Helper function for API requests
    async function makeApiRequest(url, data) {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            throw new Error(`API request to ${url} failed`);
        }
        
        const result = await response.json();
        if (result.status !== 'success') {
            throw new Error(result.message || 'Unknown API error');
        }
        
        return result;
    }
    
    // Helper function to fetch predefined seating
    async function getPredefinedSeating(tableCount, message) {
        optimizationProgress.textContent += message;
        try {
            const result = await makeApiRequest('{{ url_for("run.sub.get_predefined_seating") }}', {
                tableCount: tableCount,
                completedRounds: {{ completed_rounds }}
            });
            
            optimizationProgress.textContent += "Predefined seating template applied successfully.\n";
            return result.seating;
        } catch (error) {
            optimizationProgress.textContent += `Error: ${error.message}\nFalling back to optimization...\n`;
            throw error;
        }
    }

    // Setup UI for calculation
    function setupCalculationUI() {
        const optimizationProgress = document.getElementById('optimizationProgress');
        const previewContent = document.getElementById('previewContent');
        const statsContainer = document.getElementById('statisticsContainer');
        const currentStats = document.getElementById('currentStats');
        const newStats = document.getElementById('newStats');
        
        optimizationProgress.textContent = "";
        previewContent.textContent = "";
        substitutionPreview.style.display = 'block';
        calculateButton.disabled = true;
        
        currentStats.textContent = '';
        newStats.textContent = '';
        statsContainer.style.display = 'none';
        
        return { optimizationProgress, previewContent, statsContainer, currentStats, newStats };
    }

    calculateButton.addEventListener('click', async function() {
        try {
            const droppedOut = getDroppedOutPlayers();
            
            // Handle automatic table reduction
            let substitutesToDeactivate = [];
            if (automaticTableReductionState.required) {
                // Get selected substitutes to deactivate from UI
                const checkboxes = document.querySelectorAll('#substituteDeactivationList input[type="checkbox"]:checked');
                substitutesToDeactivate = Array.from(checkboxes).map(cb => ({
                    registration_id: cb.dataset.registrationId,
                    seating_id: parseInt(cb.dataset.seatingId)
                }));
                
                // Validate that the correct number of substitutes are selected
                const requiredDeactivations = automaticTableReductionState.currentActiveCount - automaticTableReductionState.targetPlayerCount;
                if (substitutesToDeactivate.length !== requiredDeactivations) {
                    // This should not happen with smart checkboxes, but add safety check
                    alert(`Error: Expected ${requiredDeactivations} substitutes to be selected, but found ${substitutesToDeactivate.length}. Please refresh the page and try again.`);
                    return;
                }
                
                console.log('Automatic table reduction - substitutes to deactivate:', substitutesToDeactivate);
            } else if (droppedOut.length === 0) {
                alert('Please select players to substitute');
                return;
            }
            
            // Setup UI for calculation
            const { optimizationProgress, previewContent, statsContainer, currentStats, newStats } = setupCalculationUI();
            const selectedTime = parseInt(timeLimit.value);
            
            // Get current table count
            const newTableCount = Math.ceil(currentPlayers.length / 4);
            const oldTableCount = {{ (players_with_seating / 4)|round(0, 'ceil')|int }};
            const minTables = {{ min_tables }};
            
            // Decide on optimization strategy based on table counts
            const reduceTableCount = automaticTableReductionState.required || reduceTableCountCheckbox.checked;
            let newSeating;
            
            // If automatic table reduction is required, deactivate substitutes first
            if (automaticTableReductionState.required) {
                optimizationProgress.textContent += "Deactivating substitutes for automatic table reduction...\n";
                
                try {
                    await makeApiRequest('{{ url_for("run.sub.deactivate_substitutes") }}', {
                        substitutesToDeactivate: substitutesToDeactivate
                    });
                    optimizationProgress.textContent += "Substitutes deactivated successfully.\n";
                } catch (error) {
                    optimizationProgress.textContent += `Error deactivating substitutes: ${error.message}\n`;
                    throw error;
                }
            }
            
            // TODO when we're getting predefined seating, we're going to have to reallocate seating numbers too.
            // preserve the existing order, and just renumber them 1-n. Apply this to the google sheet.
            try {
                if (reduceTableCount && oldTableCount > minTables && newTableCount >= minTables) {
                    // Use predefined seating template
                    newSeating = await getPredefinedSeating(
                        newTableCount, 
                        "Using predefined optimal seating template...\n"
                    );
                } else if (reduceTableCount && oldTableCount > minTables) { // & we know newTableCount < minTables
                    // First get min_tables seating plan, then optimize down
                    const message = `Getting seating plan for minimum ${minTables} tables first...\n`;
                    try {
                        const baseSeating = await getPredefinedSeating(minTables, message);
                        
                        // Now optimize this seating plan down to the required table count
                        optimizationProgress.textContent += "Optimizing down to required table count...\n";
                        newSeating = await runOptimization(droppedOut, selectedTime, baseSeating);
                    } catch (error) {
                        // Fall back to regular optimization
                        newSeating = await runOptimization(droppedOut, selectedTime);
                    }
                } else {
                    // Normal optimization
                    newSeating = await runOptimization(droppedOut, selectedTime);
                }
            } catch (error) {
                // Final fallback to direct optimization
                optimizationProgress.textContent += `We hit an error, so we are using direct optimization...\n`;
                newSeating = await runOptimization(droppedOut, selectedTime);
            }
            
            // Generate and display preview
            const preview = generateSubstitutionPreview(seating, newSeating);
            previewContent.textContent = "Substitution Changes:\n\n" + preview.join('\n');
            
            // Scroll to the confirmation button
            confirmButton.scrollIntoView({behavior: 'smooth', block: 'center'});

            // Store results
            await makeApiRequest('{{ url_for("run.sub.store_seating") }}', {
                seating: newSeating
            });

            // Analyze and display statistics
            const statsData = await makeApiRequest('{{ url_for("run.sub.analyze_seating") }}', {
                seating: newSeating
            });
            
            if (statsData.status === 'success') {
                const statsContainer = document.getElementById('statisticsContainer');
                const currentStats = document.getElementById('currentStats');
                const newStats = document.getElementById('newStats');

                currentStats.textContent = formatStats(statsData.current);
                newStats.textContent = formatStats(statsData.new);
                statsContainer.style.display = 'block';
            }

        } catch (error) {
            console.error('Error:', error);
            optimizationProgress.textContent += `\nError: ${error.message}\n`;
            alert('Error during calculation. Check console for details.');
        } finally {
            calculateButton.disabled = false;
        }
    });

    confirmButton.addEventListener('click', function() {
        // Disable buttons and show processing state
        confirmButton.disabled = true;
        cancelButton.disabled = true;
        confirmButton.textContent = "Processing...";
        document.body.style.cursor = 'wait';
        
        // Get the reduce table count preference and automatic table reduction state
        const reduceTableCount = automaticTableReductionState.required || reduceTableCountCheckbox.checked;
        const droppedPlayers = getDroppedOutPlayers();
        
        // Get substitutes to deactivate if in automatic mode
        let substitutesToDeactivate = [];
        if (automaticTableReductionState.required) {
            const checkboxes = document.querySelectorAll('#substituteDeactivationList input[type="checkbox"]:checked');
            substitutesToDeactivate = Array.from(checkboxes).map(cb => ({
                registration_id: cb.dataset.registrationId,
                seating_id: parseInt(cb.dataset.seatingId)
            }));
            
            // Final validation before confirmation
            const requiredDeactivations = automaticTableReductionState.currentActiveCount - automaticTableReductionState.targetPlayerCount;
            if (substitutesToDeactivate.length !== requiredDeactivations) {
                alert(`Error: Expected ${requiredDeactivations} substitutes to be selected, but found ${substitutesToDeactivate.length}. Please refresh the page and try again.`);
                // Re-enable buttons and restore cursor if validation fails
                confirmButton.disabled = false;
                cancelButton.disabled = false;
                confirmButton.textContent = "Do these substitutions";
                document.body.style.cursor = 'default';
                return;
            }
        }
        
        const requestData = {
            reduceTableCount: reduceTableCount,
            droppedPlayers: droppedPlayers,
            automaticTableReduction: automaticTableReductionState.required,
            substitutesToDeactivate: substitutesToDeactivate
        };
        
        console.log('=== CONFIRM SUBSTITUTIONS REQUEST ===');
        console.log('Request data being sent:', requestData);
        
        fetch('{{ url_for("run.sub.confirm_substitutions") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData),
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert('Substitutions applied successfully');
                window.location.href = "{{ url_for('run.run_tournament') }}";
            } else {
                // Re-enable buttons and restore cursor if there's an error
                confirmButton.disabled = false;
                cancelButton.disabled = false;
                confirmButton.textContent = "Do these substitutions";
                document.body.style.cursor = 'default';
                alert('Error applying substitutions: ' + (data.message || 'Unknown error'));
            }
        })
        .catch(error => {
            // Also handle network errors
            confirmButton.disabled = false;
            cancelButton.disabled = false;
            confirmButton.textContent = "Do these substitutions";
            document.body.style.cursor = 'default';
            alert('Network error occurred. Please try again.');
            console.error('Error:', error);
        });
    });

    cancelButton.addEventListener('click', function() {
        substitutionPreview.style.display = 'none';
    });

    undoButton.addEventListener('click', function() {
        fetch('{{ url_for("run.sub.undo_substitution") }}', {
            method: 'POST',
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert('Last substitution undone');
                location.reload();
            } else {
                alert('Error undoing substitution');
            }
        });
    });

    // Helper function to run optimization with worker
    async function runOptimization(droppedOut, timeLimit, baseSeating = null) {
        const worker = new Worker("{{ url_for('static', filename='js/seating/optimizer.worker.js') }}");
        
        return new Promise((resolve, reject) => {
            worker.onmessage = function(e) {
                if (e.data.type === 'progress') {
                    optimizationProgress.textContent += e.data.message;
                    optimizationProgress.scrollTop = optimizationProgress.scrollHeight;
                } else if (e.data.type === 'result') {
                    resolve(e.data.seating);
                }
            };
            worker.onerror = reject;
            
            const workerData = {
                seats: baseSeating || seating,
                fixedRounds: {{ completed_rounds }},
                omitPlayers: droppedOut,
                substitutes: Array.from(
                    {length: 4}, 
                    (_, i) => Math.max(...seating[0].flat()) + 1 + i
                ),
                timeLimit: timeLimit
            };
            
            worker.postMessage(workerData);
        });
    }

    // Call updateTableReductionOptions on initial load
    updateTableReductionOptions();
});
</script>
{% endblock %}
